Perfect—let’s map each part of the Formalize-style app to your **Linode VPS + Docker** and give you a **ready-to-run scaffold**. You can paste these files into a fresh folder at the root of your Laravel project.

---

# 0) Targets (what we’re building)

* **app**: PHP-FPM container running Laravel 12
* **web**: reverse proxy (Caddy or Nginx) in front of app
* **db**: PostgreSQL
* **redis**: cache, sessions, queues
* **queue**: Laravel Horizon (or queue:work) worker
* **scheduler**: cron for `artisan schedule:run`
* **minio**: S3-compatible object storage (file uploads, attachments)
* **mailhog** (dev only): catch outbound email locally
* **meilisearch** (optional): fast full-text search with Scout
* **vite** (optional): run dev server in a node container (or keep on host)

You can run this all on one VPS now, and split later.

---

# 1) Directory layout

```
your-laravel-app/
├─ docker/
│  ├─ app/Dockerfile
│  ├─ app/php.ini
│  ├─ web/Caddyfile        # or nginx.conf (pick one stack)
│  └─ web/Dockerfile
├─ docker-compose.yml
├─ .env.docker             # env overrides for containers
└─ (your existing Laravel files…)
```

---

# 2) Dockerfiles

## docker/app/Dockerfile  (PHP 8.2 + needed extensions)

```Dockerfile
FROM php:8.2-fpm

# System deps
RUN apt-get update && apt-get install -y \
    git curl zip unzip libpq-dev libonig-dev libzip-dev libicu-dev libpng-dev \
    libxml2-dev libonig-dev libssl-dev libssl3 \
    && rm -rf /var/lib/apt/lists/*

# PHP extensions
RUN docker-php-ext-install intl pdo pdo_pgsql bcmath opcache

# Redis extension
RUN pecl install redis && docker-php-ext-enable redis

# Opcache recommended settings
RUN { \
  echo 'opcache.enable=1'; \
  echo 'opcache.enable_cli=1'; \
  echo 'opcache.memory_consumption=256'; \
  echo 'opcache.max_accelerated_files=20000'; \
  echo 'opcache.validate_timestamps=0'; \
} > /usr/local/etc/php/conf.d/opcache-recommended.ini

# Composer
COPY --from=composer:2 /usr/bin/composer /usr/bin/composer

# App dir
WORKDIR /var/www/html

# PHP ini overrides (optional)
COPY php.ini /usr/local/etc/php/conf.d/zzz-app.ini

# Copy (use bind mounts in compose for dev; copy for prod build)
# COPY . /var/www/html

# Permissions for storage/bootstrap
RUN usermod -u 1000 www-data && groupmod -g 1000 www-data
RUN mkdir -p storage bootstrap/cache && chown -R www-data:www-data storage bootstrap/cache

USER www-data

CMD ["php-fpm", "-F"]
```

## docker/app/php.ini (minimal)

```ini
memory_limit=512M
upload_max_filesize=50M
post_max_size=60M
max_execution_time=120
```

## docker/web/Dockerfile (Caddy option)

```Dockerfile
FROM caddy:2.8
WORKDIR /srv
COPY Caddyfile /etc/caddy/Caddyfile
```

## docker/web/Caddyfile (fast HTTPS with Let’s Encrypt; change domain)

```caddyfile
# For local/dev, you can run: http://localhost
# For prod, replace example.com with your domain and ensure DNS points to VPS.

example.com {
    encode zstd gzip
    root * /var/www/html/public
    php_fastcgi app:9000
    file_server
    header {
        # Security headers (tune as needed)
        X-Content-Type-Options nosniff
        X-Frame-Options DENY
        Referrer-Policy no-referrer-when-downgrade
        Permissions-Policy interest-cohort=()
        Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
    }
    @assets {
        path_regexp static \.(css|js|png|jpg|jpeg|webp|svg|ico|woff2?)$
    }
    header @assets Cache-Control max-age=31536000,public,immutable
}
```

> Prefer Caddy for simplicity. If you’d rather use Nginx, swap the web image + config accordingly.

---

# 3) docker-compose.yml

```yaml
version: "3.9"
services:
  app:
    build:
      context: .
      dockerfile: docker/app/Dockerfile
    image: laravel-app:latest
    container_name: app
    restart: unless-stopped
    env_file:
      - .env
      - .env.docker
    volumes:
      - ./:/var/www/html:cached
    depends_on:
      - db
      - redis
      - minio
    networks: [appnet]

  web:
    build:
      context: .
      dockerfile: docker/web/Dockerfile
    image: laravel-web:latest
    container_name: web
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./:/var/www/html:ro
    depends_on:
      - app
    networks: [appnet]

  queue:
    image: laravel-app:latest
    container_name: queue
    restart: unless-stopped
    command: php artisan horizon
    env_file:
      - .env
      - .env.docker
    volumes:
      - ./:/var/www/html:cached
    depends_on: [app, redis, db]
    networks: [appnet]

  scheduler:
    image: laravel-app:latest
    container_name: scheduler
    restart: unless-stopped
    entrypoint: [ "sh", "-c", "while [ true ]; do php artisan schedule:run --verbose --no-interaction; sleep 60; done" ]
    env_file:
      - .env
      - .env.docker
    volumes:
      - ./:/var/www/html:cached
    depends_on: [app, redis, db]
    networks: [appnet]

  db:
    image: postgres:16
    container_name: db
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${DB_DATABASE:-laravel}
      POSTGRES_USER: ${DB_USERNAME:-laravel}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-secret}
    volumes:
      - pgdata:/var/lib/postgresql/data
    networks: [appnet]

  redis:
    image: redis:7-alpine
    container_name: redis
    restart: unless-stopped
    networks: [appnet]

  minio:
    image: minio/minio:latest
    container_name: minio
    restart: unless-stopped
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER:-minio}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD:-minio123}
    command: server /data --console-address ":9001"
    ports:
      - "9000:9000"  # S3 API
      - "9001:9001"  # Web console
    volumes:
      - miniodata:/data
    networks: [appnet]

  mailhog:
    image: mailhog/mailhog:latest
    container_name: mailhog
    restart: unless-stopped
    ports:
      - "8025:8025"
    networks: [appnet]

  # Optional: separate node container to run Vite dev server
  vite:
    image: node:22-alpine
    container_name: vite
    working_dir: /var/www/html
    command: sh -c "npm ci && npm run dev"
    volumes:
      - ./:/var/www/html
    ports:
      - "5173:5173"
    networks: [appnet]

volumes:
  pgdata:
  miniodata:

networks:
  appnet:
    driver: bridge
```

---

# 4) .env configuration (Laravel ⇄ services)

Create `.env.docker` alongside your normal `.env` (values here override or fill in):

```env
APP_ENV=production
APP_DEBUG=false
APP_URL=https://example.com

# DB (Postgres)
DB_CONNECTION=pgsql
DB_HOST=db
DB_PORT=5432
DB_DATABASE=laravel
DB_USERNAME=laravel
DB_PASSWORD=secret

# Cache / Session / Queue
CACHE_DRIVER=redis
SESSION_DRIVER=redis
SESSION_LIFETIME=120
QUEUE_CONNECTION=redis
REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

# Mail (Mailhog in dev; change in prod)
MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="noreply@example.com"
MAIL_FROM_NAME="YourApp"

# Filesystem (MinIO as S3)
FILESYSTEM_DISK=s3
AWS_ACCESS_KEY_ID=minio
AWS_SECRET_ACCESS_KEY=minio123
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=app-uploads
AWS_URL=
AWS_ENDPOINT=http://minio:9000
AWS_USE_PATH_STYLE_ENDPOINT=true

# Horizon
HORIZON_PREFIX=hzn:

# Trusted proxies / hosts (behind Caddy)
TRUSTED_PROXIES=*
TRUSTED_HOSTS=example.com
```

**First-run step for MinIO bucket:**

* Visit `http://<your-vps-ip>:9001` (MinIO console), login `minio / minio123` (change in prod), create bucket `app-uploads`.
* Or script it with `mc` CLI later.

---

# 5) Laravel app tweaks

* **Queue/Horizon**: install Horizon (nicer monitoring)

  ```bash
  composer require laravel/horizon
  php artisan horizon:install
  php artisan migrate
  ```

  Add auth to `/horizon` route via `Horizon::auth()` in `app/Providers/HorizonServiceProvider.php`.

* **Redis**: already enabled via PHP ext + env.

* **Filesystem S3**: Laravel’s S3 driver works with MinIO via `AWS_ENDPOINT` and `AWS_USE_PATH_STYLE_ENDPOINT=true`.

* **Trusted proxies**: With Caddy/Nginx in front, set `TRUSTED_PROXIES=*` or use `\App\Http\Middleware\TrustProxies`.

* **Rate limiting**: ensure `RateLimiter` is tuned for public whistleblowing intake endpoints.

* **CORS / CSP**: add CSP headers in Caddy (already some) and/or use a middleware (e.g., `spatie/laravel-csp`).

---

# 6) Bring-up commands (on the VPS)

```bash
# 1) Install Docker + Compose plugin on VPS (Ubuntu examples available online)

# 2) Clone your repo to the VPS and cd into it
git clone <your-repo> app && cd app

# 3) Create envs
cp .env.example .env
# set APP_KEY etc.
php -r "file_exists('.env') || copy('.env.example', '.env');"
php artisan key:generate

# 4) Create .env.docker using the template above (edit domain, passwords)

# 5) Build & start
docker compose build
docker compose up -d

# 6) Install composer deps in the container
docker compose exec -u www-data app composer install --no-dev --optimize-autoloader

# 7) Run migrations & assets build (your scripts already help here)
docker compose exec -u www-data app php artisan migrate --force
docker compose exec -u www-data app php artisan storage:link

# (Optional) If you want Vite dev UI hot-reload from container
docker compose up -d vite
```

> For production, run `npm run build` on CI and serve versioned assets from `public/build`. You can also do it inside the app container.

---

# 7) Optional: Nginx alternative

If you prefer Nginx, replace the `web` Dockerfile with `nginx:stable-alpine` and mount an `nginx.conf` like:

```nginx
server {
    listen 80;
    server_name _;
    root /var/www/html/public;

    index index.php;
    charset utf-8;
    client_max_body_size 50M;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        fastcgi_pass app:9000;
        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
        include fastcgi_params;
    }

    location ~* \.(css|js|jpg|jpeg|png|webp|gif|ico|svg|woff|woff2)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        try_files $uri $uri/;
    }
}
```

Then handle TLS with a companion (e.g., **nginx-proxy + acme-companion**), or terminate TLS at **Cloudflare**.

---

# 8) E2E Encryption hooks (where they live)

* **Public intake page** (your Inertia React route): use **WebCrypto** to generate/unwrap keys and **encrypt** the report payload and attachments **before** sending to `/api/channels/{id}/reports`.
* Server stores ciphertext (and metadata) only.
* **Case manager UI**: load case, fetch encrypted messages, **decrypt client-side** after auth.
* Store only encrypted blobs and non-sensitive metadata in DB and S3 (MinIO).

This keeps your security model close to a Formalize-style whistleblowing flow.

---

# 9) Backups & monitoring (starter)

* **DB backups**: nightly `pg_dump` to MinIO or off-box storage; keep 7–14 rolling copies.
* **Snapshots**: if you use Linode backups, enable them.
* **Logs**: start simple (container logs + fail2ban on VPS), graduate to **Loki + Grafana**.
* **Metrics**: node-exporter + Prometheus + Grafana; alerts to email/Telegram.
* **Uptime**: Uptime Kuma container.

---

# 10) Migration path later (if you outgrow a single VPS)

* Move MinIO to Linode Object Storage (managed).
* Move Postgres to a managed DB or a second VPS with streaming replication.
* Add a second app VM; put **Cloudflare** or Linode LB in front of two **web** nodes.
* If needed, adopt **Kubernetes (LKE)** and deploy each service as pods.

---

## TL;DR runbook

1. Add the **Dockerfiles**, **compose**, and **envs** above.
2. `docker compose up -d` to bring up the full stack.
3. `composer install`, `php artisan migrate --force`, `storage:link`.
4. Create MinIO bucket `app-uploads`.
5. Point your domain at the VPS and set the Caddyfile domain.
6. Start building features (Core → Whistleblowing intake → Case manager → Risk lite).

If you want, I can also drop in:

* a **Makefile** with `make up/down/seed/deploy` shortcuts, and
* a **starter Laravel config** for Horizon, Scout+Meilisearch, and a basic **feature-flag** Eloquent model (for “add-ons”).
