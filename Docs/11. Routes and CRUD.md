# Routes & CRUD Cheat Sheet

Laravel + Inertia uses a layered flow for CRUD:

1. **Route** (defines URI + middleware)
2. **Controller action** (grabs/validates data, returns response)
3. **Model** (Eloquent to DB)
4. **Front-end Inertia page** (React component consuming props)
5. **Forms / API calls** (use Inertia form helpers to POST/PUT/DELETE)

Below is a concrete walk-through using the **Channel** model as the example. We’ll cover:
- Where to register routes
- How controllers and models interact
- How the front end references routes
- What the `@see` / `@route` comments are
- How Inertia and Laravel converge for CRUD

---

## 1. Server-side Routing

Laravel route files live in `routes/`. For tenant-scoped modules, add a group in `routes/web.php` or a dedicated file.

Example (pseudo) – add inside the authenticated tenant group:

```php
Route::middleware(['auth', 'tenant'])->group(function () {
    Route::get('/channels', [ChannelController::class, 'index'])->name('channels.index');
    Route::post('/channels', [ChannelController::class, 'store'])->name('channels.store');
    Route::get('/channels/{channel}', [ChannelController::class, 'show'])->name('channels.show');
    Route::put('/channels/{channel}', [ChannelController::class, 'update'])->name('channels.update');
    Route::delete('/channels/{channel}', [ChannelController::class, 'destroy'])->name('channels.destroy');
});
```

This:
- Links HTTP verbs to controller methods.
- Applies middleware (`auth`, `tenant`) to scope everything to the selected org.
- Uses Eloquent route model binding (e.g., `{channel}` resolves to `Channel` model).

For simple read-only data (e.g., `index`), a `GET` is enough; for create/update/delete use `POST/PUT/DELETE`. Laravel also supports `Route::resource('channels', ChannelController::class)` to generate all 7 RESTful routes automatically.

---

## 2. Controller Actions

Controllers live under `app/Http/Controllers`. Each method:
- Validates input (if needed)
- Uses models/services to interact with DB
- Returns an Inertia response (for full page) or a redirect + flash messages

Example (simplified):

```php
class ChannelController extends Controller
{
    public function index(Request $request): Response
    {
        $channels = Channel::forOrganization($request->attributes->get('tenant'))
            ->latest()
            ->get();

        return Inertia::render('channels/index', [
            'channels' => $channels,
        ]);
    }

    public function store(ChannelRequest $request): RedirectResponse
    {
        Channel::create([
            'organization_id' => tenant()->id,
            'name' => $request->name,
            'slug' => Str::slug($request->name),
            'status' => ChannelStatus::ACTIVE,
            'intake_settings' => $request->intake_settings,
            'public_key' => $request->public_key,
        ]);

        return redirect()->route('channels.index')->with('success', 'Channel created');
    }
}
```

Key points:
- `tenant()` helper (custom) or `$request->attributes->get('tenant')` to access current org.
- Use `ScopedByOrganization` trait (`Channel::forOrganization(...)`) to enforce `organization_id` filtering.
- Returning `Inertia::render` sends props to the React page; returning `redirect()` after mutating data is the normal pattern.

---

## 3. Model Layer

Models live in `app/Models`. For Channel we already have:

```php
class Channel extends Model
{
    use HasUuid;
    use ScopedByOrganization;

    protected $guarded = [];

    protected $casts = [
        'intake_settings' => 'array',
        'status' => ChannelStatus::class,
    ];
}
```

CRUD operations happen via Eloquent (`Channel::create`, `$channel->update`, `$channel->delete`). Ensure default scoping by using the `ScopedByOrganization` trait (our custom helper) or a Global Scope.

---

## 4. Front-end: Inertia Pages & Forms

React pages live under `resources/js/pages`. For channels we’d create `resources/js/pages/channels/index.tsx` (list) and maybe `edit.tsx`.

`index.tsx` would receive the `channels` prop (from the controller). For example:

```tsx
import ChannelController from '@/actions/App/Http/Controllers/ChannelController';
import { Form, Link } from '@inertiajs/react';

export default function ChannelsIndex({ channels }) {
  return (
    <div>
      <h1>Channels</h1>
      <Link href={ChannelController.create.url()}>Create Channel</Link>
      <ul>
        {channels.map((channel) => (
          <li key={channel.id}>{channel.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

For forms, use Inertia’s `<Form>` or `useForm` to POST to server routes:

```tsx
const form = useForm({
  name: '',
  intake_settings: {},
});

function submit() {
  form.post(ChannelController.store.url());
}
```

`ChannelController.store.url()` comes from Wayfinder-generated route helpers (see section below).

---

## 5. Route Helpers in Front-end (Wayfinder)

In `resources/js/actions/...` we have TypeScript files generated by **Wayfinder** (shipped with the starter). They’re created by scanning PHP routes/controllers. Example snippet:

```ts
/**
* @see \App\Http\Controllers\Auth\AuthenticatedSessionController::store
* @see app/Http/Controllers/Auth/AuthenticatedSessionController.php:32
* @route '/login'
*/
export const store = (options?: RouteQueryOptions): RouteDefinition<'post'> => ({
    url: store.url(options),
    method: 'post',
});
```

This tells you:
- `@see` – PHP controller method this function maps to.
- `@route` – the URI path.
- `:32` – line number in the PHP file (for dev reference).

**Do you need to edit these comments?** No. They’re auto-generated and keep the TS routes in sync with PHP routes. If you add new routes/controllers, run the Wayfinder generator (`php artisan wayfinder:scan`) to update these route helpers. They’re similar to the `php artisan route:list` but produce typed TS helpers.

On the front-end you import these helpers for forms/links to avoid hardcoding strings, e.g. `ChannelController.store.form()` or `ChannelController.index.url()`.

---

## 6. API vs Inertia

- **Inertia approach**: Controllers return `Inertia::render` (full pages) or redirects. The React side uses data props + Inertia forms. This feels like a classic server-rendered app but with React.
- **API approach**: You could expose JSON endpoints (e.g., inside `routes/api.php`), returning `ChannelResource::collection(...)`. Then the front end fetches them via Axios. We’re **not** doing that here; we’re using Inertia to avoid maintaining separate JSON APIs unless needed.
- If you need background API usage (e.g., inline search), you can add JSON routes returning `Response::json` and call them via `fetch`.

---

## 7. Namespacing & Back-end Helpers

- Controllers: `namespace App\Http\Controllers;`
- Models: `App\Models\`
- Requests (form validation): `App\Http\Requests\`
- Use `Illuminate\Support\Facades\` for helpers like `Auth`, `Route`, `DB`.
- Inertia: `use Inertia\Inertia;` to build responses.
- Form requests: create `ChannelRequest` to centralize validation.

When adding new files:
- Controller names map to PHP files in `app/Http/Controllers`.
- Use PSR-4 namespacing; composer autoload (defined in `composer.json`) handles discovery.
- After new classes, run `composer dump-autoload` or rely on auto-discovery.

---

## 8. Practical CRUD Flow for Channels

1. **Create migration & model** (already done).
2. **Add routes** in `routes/web.php`.
3. **Generate controller** (`php artisan make:controller ChannelController`).
4. **Write methods** (`index`, `create`, `store`, `edit`, `update`, `destroy`).
5. **Create React pages** under `resources/js/pages/channels/...`.
6. **Use route helpers** from `resources/js/actions/...` to submit forms or link to pages.
7. **Test** with feature tests (e.g., `php artisan make:test ChannelTest`).

Optional: use `Route::resource('channels', ChannelController::class);` to quickly register canonical CRUD routes.

---

## 9. Generating & Syncing Front-end Routes

Wayfinder scans PHP routes and generates TS helpers. Run when routes change:

```
php artisan wayfinder:scan
```

This outputs under `resources/js/actions/**`. Comments (`@see`, `@route`) are annotations for humans and editors (Intelephense) so you can jump to definitions. They don’t affect runtime.

---

## 10. Summary Tips

- Think of Inertia as “server-driven React”; we still use controllers for CRUD.
- For each feature: design the DB (model), add routes, implement controller actions, then build Inertia pages using props. Forms call the route helpers to mutate data.
- Use policy middleware (`can:`) or guard methods inside controllers to check role/permission before `store/update/destroy`.
- Keep organization scoping consistent by pulling the tenant in middleware and applying `->forOrganization($tenant)`.
- Documentation in `Docs/7 Models`, `Docs/8 Factories`, and `Docs/10 Pages` shows what data to load where.

With this pattern, you can extend the app’s CRUD features: new menu item → add route → controller method → page component → Inertia form. Everything stays type-safe via the generated TS helpers.
