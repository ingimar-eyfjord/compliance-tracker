awesome — here’s a crisp, opinionated MVP plan you can execute on your VPS + Docker stack. it’s split into:

1. data model (MVP)
2. APIs (resources, verbs, validation)
3. middleware & policies
4. routes (public vs authenticated)
5. jobs, events, notifications
6. infra-as-code + ops
7. test plan & acceptance criteria
8. epics & backlog (MVP vs polish), tagged with patterns

i’ve separated **Core Platform** from **Whistleblowing**. everything assumes Laravel 12 + Inertia React (Option 1).

---

# 1) Data model (MVP)

## 1.1 Core Platform (multi-tenant, RBAC, audit)

* **organizations**

  * `id (uuid)`, `name`, `slug`, `plan_tier [free|pro|enterprise]`, `features(jsonb)`, `owner_user_id`, `domain`, `created_at`, `updated_at`
* **users**

  * `id (uuid)`, `name`, `email (unique)`, `password_hash`, `locale`, `last_login_at`, `created_at`, `updated_at`
* **organization_user (pivot)**

  * `organization_id`, `user_id`, `role [owner|admin|manager|agent|viewer]`, `invited_by`, `status [active|invited|disabled]`, timestamps, unique(org,user)
* **roles** (optional if using spatie/permission)

  * `id`, `name`, `guard_name`, timestamps
* **permissions** (optional)

  * `id`, `name`, `guard_name`, timestamps
* **model_has_roles / role_has_permissions** (from spatie/permission)
* **audit_logs**

  * `id`, `organization_id`, `user_id (nullable)`, `actor_type [user|system|api]`, `event [created|updated|deleted|…]`, `entity_type`, `entity_id`, `diff(jsonb)`, `ip`, `ua`, `created_at`
* **feature_flags**

  * `id`, `organization_id`, `feature_key`, `enabled_at`, `expires_at (nullable)`, `meta(jsonb)`

## 1.2 Whistleblowing (E2E encrypted intake & case mgmt)

* **channels** (public intake endpoints per org / topic)

  * `id (uuid)`, `organization_id`, `name`, `slug`, `status [active|archived]`, `intake_settings(jsonb)`, `public_key (PEM|JWK)` *(for client-side encryption)*, timestamps
* **reports**

  * `id (uuid)`, `organization_id`, `channel_id`, `status [new|triage|in_progress|resolved|closed]`, `ciphertext(jsonb or text)`, `metadata(jsonb)`, `created_via [web|email|import|api]`, `created_at`, `updated_at`
* **cases** (1:1 with report initially, keep separate for future merges/splits)

  * `id (uuid)`, `organization_id`, `report_id`, `assignee_user_id (nullable)`, `priority [low|med|high]`, `tags(jsonb)`, `due_at (nullable)`, timestamps
* **case_messages** (two-way, encrypted content)

  * `id`, `case_id`, `sender_type [agent|reporter|system]`, `ciphertext(text)`, `attachments(jsonb)`, `sent_at`
* **attachments** (metadata only; blob goes to MinIO)

  * `id`, `organization_id`, `case_id (nullable)`, `report_id (nullable)`, `disk [s3]`, `path`, `original_name`, `size`, `mime`, `checksum`, `created_at`
* **case_events** (timeline)

  * `id`, `case_id`, `event [status_changed|assigned|message_sent|attachment_added|deadline_set|…]`, `actor_user_id (nullable)`, `data(jsonb)`, `created_at`

> **Note:** encrypted fields store ciphertext only (key material stays client-side).

---

# 2) APIs (MVP)

All `/api/*` are JSON. Use Sanctum (SPA) for auth; rate-limit public endpoints.

## 2.1 Core

* `POST /api/auth/login` → {token or SPA cookie}
* `POST /api/auth/logout`
* `GET /api/me` → profile + org memberships
* `GET /api/orgs/current` → current org context (features, plan)
* `PATCH /api/orgs/current` → update org settings (owner/admin only)
* `GET /api/users` (org scoped) → list members (RBAC)
* `POST /api/users/invite` → invite user (email)
* `PATCH /api/users/{id}` → role/status
* `GET /api/feature-flags` → enabled features for org

## 2.2 Whistleblowing — public intake

* `GET /public/channels/{slug}` → minimal channel metadata + **JWK/PEM public key** (no secrets)
* `POST /public/channels/{slug}/reports`

  * **Body:** `{ ciphertext, attachments[] }` — already E2E encrypted in the browser
  * **Validations:** size limits, content-type, rate limit (e.g., 10/min/IP), captcha (hCaptcha/Cloudflare Turnstile)

## 2.3 Whistleblowing — internal

* `GET /api/cases?status=&assignee=&q=`
* `POST /api/cases/{id}/assign` → `{assignee_user_id}`
* `PATCH /api/cases/{id}` → priority, due date, tags, status
* `GET /api/cases/{id}/messages`
* `POST /api/cases/{id}/messages` → `{ciphertext, attachments[]}`
* `POST /api/cases/{id}/attachments` → file upload (server stores blob in MinIO)
* `GET /api/reports/{id}` → metadata only (no plaintext), link to case

**Validation (examples):**

* channel slug exists & active; payload size < N MB; mime whitelist; attachments count; CSRF on internal routes; public routes use rate limits + captcha.

---

# 3) Middleware & Policies

**Global middleware**

* `TrustProxies`, `TrimStrings`, `EncryptCookies`, `StartSession`, `ShareErrorsFromSession`, `VerifyCsrfToken` (for SPA), `SubstituteBindings`
* `ForceJson` (custom) for `/api/*` to always return JSON
* `SetOrganizationContext` (custom) reads org from subdomain or selected org in session, applies scope

**Route middleware**

* `auth:sanctum` for internal API/SPA routes
* `throttle:public-intake` for `/public/*` (e.g., 10/min/IP)
* `throttle:api` for internal
* `signed` (if you send signed links to reporters)
* `abilities:*` if using token abilities

**Policies / Gates**

* `CasePolicy` (view, update, message, assign)
* `ChannelPolicy` (manage channels)
* `UserPolicy` (invite, set role)
* Use **spatie/laravel-permission**: roles per org, permissions like `case.view`, `case.update`, `channel.manage`.

**Security headers**

* CSP allowlists for app domain + CDN; `X-Frame-Options=DENY`, `HSTS`, etc. (Caddy/Nginx + middleware)

---

# 4) Routes (grouping)

```php
// routes/api.php
Route::prefix('auth')->group(function () {
  Route::post('login', [AuthController::class, 'login']);
  Route::post('logout', [AuthController::class, 'logout'])->middleware('auth:sanctum');
});
Route::middleware(['auth:sanctum','set.org'])->group(function () {
  Route::get('/me', MeController::class);
  Route::get('/orgs/current', OrgController::class.'@show');
  Route::patch('/orgs/current', OrgController::class.'@update');

  Route::get('/users', UserController::class.'@index');
  Route::post('/users/invite', UserInviteController::class.'@store');

  Route::get('/cases', CaseController::class.'@index');
  Route::get('/cases/{id}', CaseController::class.'@show')->can('view','case');
  Route::patch('/cases/{id}', CaseController::class.'@update')->can('update','case');
  Route::post('/cases/{id}/assign', CaseAssignController::class.'@store')->can('assign','case');
  Route::get('/cases/{id}/messages', CaseMessageController::class.'@index')->can('view','case');
  Route::post('/cases/{id}/messages', CaseMessageController::class.'@store')->can('message','case');
  Route::post('/cases/{id}/attachments', CaseAttachmentController::class.'@store')->can('update','case');
});

// routes/public.php (or web.php with neutral middleware)
Route::prefix('public')->middleware(['throttle:public-intake'])->group(function () {
  Route::get('channels/{slug}', PublicChannelController::class.'@show');          // returns JWK/PEM
  Route::post('channels/{slug}/reports', PublicReportController::class.'@store'); // ciphertext+files
});
```

---

# 5) Jobs, Events, Notifications

**Events**

* `ReportSubmitted` (org_id, channel_id, report_id)
* `CaseAssigned` (case_id, assignee_id)
* `CaseStatusChanged` (case_id, old, new)
* `CaseMessagePosted` (case_id, sender_type)

**Listeners / Jobs**

* `DispatchTriageNotifications` (notify team inbox/slack/email)
* `SendAssigneeNotification`
* `CreateCaseFromReport` (if you keep them separate)
* `AppendAuditLog` (centralized)
* `PurgeOrphanedUploads` (scheduled)
* `DailyDigestEmail` (summary per assignee/org)

**Notifications**

* Mail + (optional) Slack webhook; all contain **no plaintext** of encrypted content (only metadata + link).

---

# 6) Infra-as-Code & Ops (MVP)

* **Docker Compose** services you already have: `app`, `web`, `db`, `redis`, `queue`, `scheduler`, `minio`
* **IaC**: start with a `Makefile` + simple bash scripts; later port to **Terraform** (Linode provider)
* **Secrets**: `.env` via 1Password/Vault; never commit
* **Backups**: nightly `pg_dump` to MinIO with lifecycle; weekly full snapshot (Linode backups)
* **TLS**: Caddy auto-TLS (or Cloudflare)
* **Monitoring**: start with healthchecks + Uptime Kuma; later Prometheus/Grafana
* **CI**: GitHub Actions → run tests, build assets, ssh to VPS and `docker compose pull && up -d`

---

# 7) Test plan & acceptance criteria (MVP)

**Unit**

* Policies (RBAC matrix per role)
* Validators (intake payload size/mime/captcha)
* Feature flags (given org tier, features visible)

**Feature / HTTP**

* Public report submission → returns 201; attachments stored; no plaintext in DB
* Internal case listing → respects org/role; filtering by status/assignee
* Messaging → encrypted blobs persisted; audit entries created
* Rate limiting on public endpoints
* Invitations flow → invited user can join; roles applied

**Acceptance**

* As a reporter, I can submit an encrypted report with attachments to a channel and get a receipt (case reference) without creating an account.
* As an agent, I can see a case’s metadata, assign it, change status, and exchange messages (ciphertext only server-side).
* As an org admin, I can invite teammates and toggle features (e.g., enable Risk later).

---

# 8) Epics & backlog

## MVP Epics (tagged)

1. **EP-CORE-TENANCY: Organization & RBAC** *(DDD, Policy, Factory)*

   * Org CRUD (owner)
   * User invites & roles (spatie/permission)
   * Org context middleware / scoping
   * Audit log (observer pattern)
   * **Done when:** org owner can invite agents; actions recorded; access scoped.

2. **EP-WB-INTAKE: Public Channel & E2E Intake** *(Strategy, Gateway, Builder)*

   * Channel CRUD (internal) + public show (key exposure)
   * WebCrypto service (frontend) — generate/use channel public key
   * POST `/public/channels/{slug}/reports` (rate limit, captcha)
   * Attachment handling to MinIO
   * **Done when:** encrypted report & files persist, no plaintext server-side.

3. **EP-WB-CASE: Case Management & Messaging** *(DDD Aggregate, CQRS-lite)*

   * Case creation from report, status transitions with rules
   * Case inbox (filters, pagination)
   * Case messages (encrypted), attachments
   * Assignments, due dates, priorities
   * Timeline (case_events)
   * **Done when:** agents can triage, work, resolve, and converse.

4. **EP-OBSERVABILITY: Audit, Notifications, Rate Limits** *(Observer, Publisher-Subscriber)*

   * Central audit logs on mutating actions
   * Notifications (mail/slack) with metadata only
   * Public throttle + ip/captcha; internal throttle
   * **Done when:** events visible; noisy/spam intake mitigated.

5. **EP-OPS-MVP: Deployment & Backups** *(IaC, Twelve-Factor)*

   * Compose stack on VPS, health checks
   * Daily pg_dump to MinIO; weekly snapshot
   * TLS + CSP headers; basic monitoring
   * **Done when:** green deploy, backups verifiable, HTTPS enforced.

## Post-MVP / “polish” Epics

6. **EP-WB-REPORTER-PORTAL** *(State Machine, Token Auth)*

   * Magic link / signed link for reporter to read/respond anonymously
   * Message notifications without revealing content

7. **EP-RISK-LITE** *(DDD Module, Specification)*

   * Risks, owners, inherent/residual scoring, filters
   * Link risks ↔ cases (evidence)

8. **EP-SEARCH-SCOUT** *(Adapter)*

   * Meilisearch integration; search cases/channels by metadata/tags

9. **EP-FEATURE-FLAGS-BILLING** *(Feature Toggle, Strategy)*

   * Feature gating per org; plan tiers; (later) billing provider adapter

10. **EP-HARDENING & COMPLIANCE** *(Policy, Anti-corruption)*

* Advanced CSP; secure headers; subresource integrity
* Data retention policies; export / right-to-access tooling

11. **EP-ANGULAR-FRONTEND (optional)** *(Adapter / Ports & Adapters)*

* Standalone Angular + NgRx client over same API

---

## Field-level notes (security)

* **Never store plaintext** of report/case messages; server handles **only ciphertext** and non-sensitive metadata.
* **Attachments** go to MinIO with private ACL and signed URLs for short-lived access.
* **Logs & notifications** must avoid sensitive fields.
* **Keys**: keep channel’s **public key** public; private key material is **client-side** (or securely re-derived on client after auth).

